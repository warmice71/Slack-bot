// use path here
const spikeAuthentication = document.currentScript?.getAttribute('authId') || '';
const spikeChatId = document.currentScript?.getAttribute('chatId') || '';
const converter = new showdown.Converter();

const script_src = document.currentScript?.getAttribute('src') || '';
const path = new URL(script_src);
const API_PATH = path.origin + '/';
var spikeConversation = [];
var temperature = 0;
var model = 'gpt-3.5-turbo';
var msg_color = '#fff';
var textColor = 'black';
var spikeToken = null;
var SPIKE_DATA = null;

spike();

async function spike() {
  // document.cookie = "authorization=" + spikeAuthentication + ";";
  const { data, messages } = await spikeGetData(spikeChatId);
  SPIKE_DATA = data;

  const getTextColor = (color) => {
    const hex = color.replace('#', '');
    const r = parseInt(hex.substring(0, 2), 16);
    const g = parseInt(hex.substring(2, 4), 16);
    const b = parseInt(hex.substring(4, 6), 16);
    const brightness = (r * 299 + g * 587 + b * 114) / 1000;
    return brightness > 128 ? '#000' : '#fff'; // Return black or white based on brightness
  };

  textColor = getTextColor(data.interface.msg_color);
  spikeConversation = [
    {
      role: 'system',
      content:
        data.prompt +
        " After each page, you will ask the user if there are more pages to be added. If the user provides another page, you will repeat the process until the user writes the exact words 'END OF DATA.' Once the user has finished adding pages, you will switch to 'query mode,' where you will only answer questions related to the contents of the data."
    }
  ];
  temperature = data.temperature;
  model = data.mode;
  msg_color = data.interface.msg_color;

  const bubbleBox = document.createElement('div');
  bubbleBox.style = `height: 38rem; overflow: hidden; display: none; flex-direction: column; flex: auto; flex-shrink: 0; background-color: #f0f0f0; margin-bottom: 0.5rem; border: 1px solid #d1d5db; padding: 0.5rem; border-radius: 10px; background:${
    data.interface.theme === 'light' ? 'white' : 'black'
  }; font-family: 'Söhne',helvetica,sans-serif;`;
  bubbleBox.innerHTML = `<div style="width:100%;">
  <style>
  /**
 * ==============================================
 * Dot Flashing
 * ==============================================
 */
 .spike-dot-flashing {
  position: relative;
  width: 10px;
  height: 10px;
  border-radius: 5px;
  background-color: #5a5959;
  color: #5a5959;
  animation: spike-dot-flashing 1s infinite linear alternate;
  animation-delay: 0.5s;
}
.spike-dot-flashing::before, .spike-dot-flashing::after {
  content: "";
  display: inline-block;
  position: absolute;
  top: 0;
}
.spike-dot-flashing::before {
  left: -15px;
  width: 10px;
  height: 10px;
  border-radius: 5px;
  background-color: #5a5959;
  color: #5a5959;
  animation: spike-dot-flashing 1s infinite alternate;
  animation-delay: 0s;
}
.spike-dot-flashing::after {
  left: 15px;
  width: 10px;
  height: 10px;
  border-radius: 5px;
  background-color: #5a5959;
  color: #5a5959;
  animation: spike-dot-flashing 1s infinite alternate;
  animation-delay: 1s;
}

input::-webkit-outer-spin-button,
input::-webkit-inner-spin-button {
  -webkit-appearance: none;
  margin: 0;
}

@keyframes spike-dot-flashing {
  0% {
    background-color: #5a5959;
  }
  50%, 100% {
    background-color: rgba(99, 99, 99, 0.2);
  }
}
  </style>
    <div style="display: flex; justify-content: space-between; padding-top: 0.25rem; padding-bottom: 0.25rem; margin-bottom: 1rem; border-bottom: '1px solid rgb(241, 241, 240)'; background:${
      data.interface.theme === 'light' ? 'white' : 'black'
    }; border-bottom: 1px solid rgb(241, 241, 240);">
    <div style="display: flex; align-items: center; gap: 0.5rem;">
          ${
            !data.interface.remove_img
              ? data.interface.img
                ? `<img src='${data.interface.img}' style="width: 2.5rem; height: 2.5rem; border-radius: 100%;" />`
                : ''
              : ''
          }
          <p style="color: ${data.interface.theme === 'dark' ? 'white' : 'black'}; margin: 0;">
            ${data.interface.display_name}
          </p>
        </div>
        <div style="display: flex; justify-content: center; align-items: center;">
  <button style="font-size: 0.875rem; padding-top: 0.75rem; padding-bottom: 0.75rem; cursor: pointer; color: #3b3b3b; transition: color 0.2s ease-in-out; border: 0; background: none;" onClick="return spikeResetChat()">
  <svg
  xmlns="http://www.w3.org/2000/svg"
  fill="none"
  viewBox="0 0 24 24"
  strokeWidth="1.5"
  stroke="currentColor"
  aria-hidden="true"
  style="height: 1.25rem; width: 1.25rem; color: ${data?.interface.theme === 'dark' ? 'white' : 'black'};"
>
  <path
    strokeLinecap="round"
    strokeLinejoin="round"
    d="M16.023 9.348h4.992v-.001M2.985 19.644v-4.992m0 0h4.992m-4.993 0l3.181 3.183a8.25 8.25 0 0013.803-3.7M4.031 9.865a8.25 8.25 0 0113.803-3.7l3.181 3.182m0-4.991v4.99"
  ></path>
</svg>

          </button>
          <button
  style="font-size: 0.875rem; padding-top: 0.75rem; padding-bottom: 0.75rem; margin-left: 0.75rem; cursor: pointer; color: #3b3b3b; border: 0; background: none;"
  id="spikeClose"
>
          <svg
  xmlns="http://www.w3.org/2000/svg"
  fill="none"
  viewBox="0 0 24 24"
  strokeWidth="1.5"
  stroke="currentColor"
  aria-hidden="true"
  style="height: 1.5rem; width: 1.5rem; color:${data?.interface.theme === 'dark' ? 'white' : 'black'}"
>
  <path
    strokeLinecap="round"
    strokeLinejoin="round"
    d="M6 18L18 6M6 6l12 12"
  ></path>
</svg>
</button>
        </div>
      </div>
    </div>
    
  <div style="height: 100%; overflow: auto; scrollbar-width: 1px; scrollbar-color: #888 #f1f1f1; scroll-behavior: smooth;" id="SPIKE-MSG-BOX">
  <div style="display: flex; flex-direction: column; align-items: flex-start; gap: 1rem; word-wrap: break-word;">
    <div style="padding-right: 0.5rem;">
      <div style="background-color: rgb(241, 241, 240); color: black; overflow: auto; max-width: 65ch; margin-bottom: 0.3rem; padding: 0.75rem; border-radius: 0.375rem;">
          <div style="font-size: inherit; text-align: left; width: 100%; word-wrap: break-word;">
            <p style="margin: 0;">${data.interface.init_msg}</p>
          </div>
        </div>
      </div>
    </div>
    
  
</div>
<div style="clear: both;">
  <div style="padding-top: 0.75rem; display: flex; overflow-x: auto;">
    ${
      data.interface.suggest_msg &&
      data.interface.suggest_msg
        .split('\n')
        .map((item) => {
          if (item)
            return `<button
        style="border-radius: 0.375rem; white-space: nowrap; margin-right: 0.25rem; margin-top: 0.25rem; padding-top: 0.5rem; padding-bottom: 0.5rem; padding-left: 0.75rem; padding-right: 1rem; font-size: 0.875rem; background-color: #f0f0f0; color: #333; transition: background-color 0.2s ease-in-out; border: 0; cursor: pointer; margin-bottom: 3px;"
        onClick="return spikeSendPrompt('${item}')"
      >
        ${item}
      </button>`;
          else return '';
        })
        .join('')
    }
  </div>
  <form style="display: flex; padding-left: 0.75rem; padding: 0.25rem; border-radius: 0.375rem; background: ${
    data?.interface.theme === 'light' ? 'white' : 'black'
  }; border: 1px solid #e4e4e7;" id="SPIKE-CHAT-INPUT-BOX">
    <input type="text" name="text" aria-label="chat input" style="color:${
      data?.interface.theme === 'dark' ? 'white' : 'black'
    }; border: 0; min-width: 0; background: inherit; flex: 1; appearance: none; border-radius: 0.375rem; outline: none; font-size: 0.875rem;">
    <div>
      <button type="submit" style="padding: 0.5rem; flex: none; border: 0; background: none; cursor: pointer;">
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="currentColor" aria-hidden="true" style="height: 1.25rem; width: 1.25rem; fill: ${
          data?.interface.theme === 'dark' ? 'white' : 'black'
        };">
          <path d="M3.478 2.405a.75.75 0 00-.926.94l2.432 7.905H13.5a.75.75 0 010 1.5H4.984l-2.432 7.905a.75.75 0 00.926.94 60.519 60.519 0 0018.445-8.986.75.75 0 000-1.218A60.517 60.517 0 003.478 2.405z"></path>
        </svg>
      </button>
    </div>
  </form>
  <p style="text-align:center; font-size: 12px">Powered by <b>Chatlabz.com</b></p>
</div>
  </div>
`;

  const spikeChatIcon = document.createElement('div');
  spikeChatIcon.style = `display: flex; padding-bottom: 3rem; transition: all 0.2s ease-in-out; justify-content: ${
    data.interface.bubble_position === 'right' ? 'flex-end' : 'flex-start'
  };`;
  spikeChatIcon.innerHTML = `<button style="width: 2.75rem; height: 2.75rem; z-index: 99; background:  ${
    !data.interface.remove_chat_icon && data.interface.chat_icon ? 'none' : data.interface.bubble_color
  }; border: 0; border-radius: 100%; cursor: pointer; outline: 0; display: flex; align-items: center; justify-content: center;">${
    !data.interface.remove_chat_icon && data.interface.chat_icon
      ? `<img style="width: 2.75rem; height: 2.75rem; border-radius: 50%;" src="${data.interface.chat_icon}" />`
      : `<svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="white" width="24" height="24" style="fill: ${data.interface.bubble_color}; stroke-width: 2.3;">
        <path strokeLinecap="round" strokeLinejoin="round" d="M2.25 12.76c0 1.6 1.123 2.994 2.707 3.227 1.087.16 2.185.283 3.293.369V21l4.076-4.076a1.526 1.526 0 011.037-.443 48.282 48.282 0 005.68-.494c1.584-.233 2.707-1.626 2.707-3.228V6.741c0-1.602-1.123-2.995-2.707-3.228A48.394 48.394 0 0012 3c-2.392 0-4.744.175-7.043.513C3.373 3.746 2.25 5.14 2.25 6.741v6.018z"></path>
      </svg>`
  }</button>`;

  const spikeBox = document.createElement('div');
  spikeBox.style.width = '500px';
  spikeBox.style.position = 'fixed';
  spikeBox.style.bottom = '20px';
  spikeBox.style.right = '20px';
  spikeBox.style.flex = '1 1 0%';
  spikeBox.style.zIndex = '9999';
  spikeBox.style.fontFamily = '"Söhne",helvetica,sans-serif';
  spikeBox.append(bubbleBox);
  spikeChatIcon.onclick = function () {
    if (bubbleBox.style.display === 'none') {
      bubbleBox.style.display = 'flex';
    } else {
      bubbleBox.style.display = 'none';
    }
  };
  spikeBox.append(spikeChatIcon);
  document.body.appendChild(spikeBox);
  if (document.getElementById('spikeClose')) {
    document.getElementById('spikeClose').onclick = function () {
      bubbleBox.style.display = 'none';
    };
    const inputbox = document.getElementById('SPIKE-CHAT-INPUT-BOX');
    inputbox.onsubmit = async function (e) {
      e.preventDefault();
      const formData = new FormData(e.target);
      const text = formData.get('text');
      e.target.querySelector('input').value = '';

      await spikeSendPrompt(text);
    };
  }
}

async function spikeSendPrompt(chat) {
  spikeAddMessage('sent', chat);
  spikeAddMessage('received', '<div style="margin-left:20px;" role="spike-loading"><div class="spike-dot-flashing"></div></div>');
  const prompt = chat.trim();
  if (prompt !== '') {
    spikeConversation.push({
      role: 'user',
      content: prompt
    });

    try {
      const response = await fetch(API_PATH + 'api/chat/' + spikeAuthentication, {
        method: 'POST',
        headers: {
          'Content-Type': 'text/event-stream'
          // "Access-Control-Allow-Origin": "*",
        },
        // credentials: "include",
        // mode: "no-cors",
        body: JSON.stringify({ prompt: chat, id: spikeChatId })
      });

      const spikeMsgBox = document.getElementById('SPIKE-MSG-BOX')?.querySelector("div[type='received'][name='spikeMessageContainer']:last-child");
      spikeMsgBox?.querySelector("div[role='spike-loading']")?.remove();
      const spikeTextBox = spikeMsgBox?.querySelector('p');

      if (!response.ok) {
        const text = await response.text();
        throw new Error(text || 'Network response was not ok');
      }
      /**
       * Appends a new message to the chat history and updates the chat text.
       *
       * @param response - The response object containing the message content.
       * @param updatedChatHistory - The current chat history.
       * @param setChatText - The state setter function for the chat text.
       * @param setChatHistory - The state setter function for the chat history.
       */
      // updatedChatHistory.push({ role: "assistant", content: "" });
      const reader = response.body?.getReader();
      const decoder = new TextDecoder('utf-8');
      let spikeText = '';
      reader?.read().then(function processText({ done, value }) {
        if (done) {
          return;
        }
        const content = decoder.decode(value);
        spikeText += content;
        if (spikeTextBox) spikeTextBox.innerHTML = converter.makeHtml(spikeText);

        // setData(oldData => oldData + decoder.decode(value));
        return reader.read().then(processText);
      });
      // });

      // if (response.ok) {
      //   const apiResponse = await response.json();
      //   const aiMessage = apiResponse.choices[0].message.content;
      //   spikeConversation.push({
      //     role: "assistant",
      //     content: aiMessage,
      //   });

      //   // Append the AI's message to the chat container
      //   spikeRemoveLastMessage();
      //   spikeAddMessage("received", aiMessage);
      // } else {
      //   console.error("Error in spikeSendPrompt:", response.statusText);
      // }

      // Append the user's message to the chat container

      // Clear the input box
      // get local storage data contact:
      const localData = localStorage.getItem('spikeContact');

      console.log((SPIKE_DATA.leads.name || SPIKE_DATA.leads.email || SPIKE_DATA.leads.number) && !localData);
      console.log((SPIKE_DATA.leads.name, SPIKE_DATA.leads.email, SPIKE_DATA.leads.number), localData);

      if ((SPIKE_DATA.leads.name || SPIKE_DATA.leads.email || SPIKE_DATA.leads.number) && !localData) {
        spikeAddMessage(
          'received',
          `<div style="margin: 0 10px;">
<p style="color: textColor">${SPIKE_DATA.leads.title}</p>
        <form onSubmit="leadsHandler(event)" style="display: flex; flex-direction: column; gap: 0.4rem; ">
        ${
          SPIKE_DATA.leads.name
            ? `<label for="name" style="color: textColor">${SPIKE_DATA.leads.name}</label>
        <input name="name" required style="border: 1px solid #e4e4e7;  border-radius: 0.375rem; color:black;  font-size: 0.875rem; padding: 0.4rem 0.6rem;"></input>`
            : ''
        }
        ${
          SPIKE_DATA.leads.email
            ? `<label for="email" style="color: textColor">${SPIKE_DATA.leads.email}</label>
        <input name="email" type="email" required style="border: 1px solid #e4e4e7;  border-radius: 0.375rem; color:black;  font-size: 0.875rem; padding: 0.4rem 0.6rem;"></input>`
            : ''
        }
        ${
          SPIKE_DATA.leads.number
            ? `
        <label for="number" style="color: textColor">${SPIKE_DATA.leads.number}</label>
        <input type="number" name="number" required style="border: 1px solid #e4e4e7;  border-radius: 0.375rem; color:black;  font-size: 0.875rem; padding: 0.4rem 0.6rem;"></input>`
            : ''
        }
        <button style="border: 1px solid #e4e4e7;  border-radius: 0.375rem; color:black;  font-weight: bold; padding: 0.4rem 0.6rem; display: flex; justify-content: center; align-items: center; gap: 10px">Submit  <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="currentColor" aria-hidden="true" style="height: 1.25rem; width: 1.25rem; fill: textColor">
          <path d="M3.478 2.405a.75.75 0 00-.926.94l2.432 7.905H13.5a.75.75 0 010 1.5H4.984l-2.432 7.905a.75.75 0 00.926.94 60.519 60.519 0 0018.445-8.986.75.75 0 000-1.218A60.517 60.517 0 003.478 2.405z"></path>
        </svg></button>
        </form>
        </div>`
        );
      }
    } catch (error) {
      console.error('Error in spikeSendPrompt:', error);
    }
  }
}

function spikeAddMessage(type, text) {
  const messageContainer = document.createElement('div');
  messageContainer.setAttribute('name', 'spikeMessageContainer');
  messageContainer.setAttribute('type', type);

  const msg_context = `<div style="display: flex; flex-direction: column; align-items: ${
    type === 'sent' ? 'flex-end' : 'flex-start'
  }; gap: 1rem; word-wrap: break-word;">
  <div style="padding-right: 0.5rem;">
    <div style="background-color: ${
      type === 'sent' ? msg_color : 'rgb(241, 241, 240)'
    }; overflow: auto; max-width: 65ch; margin-bottom: 0.75rem; padding:0.1rem; padding-left:0.75rem; padding-right: 0.75rem; border-radius: 0.375rem;">
        <div style="font-size: inherit; text-align: left; width: 100%; word-wrap: break-word; min-inline-size: 50px;">
            <p style='${type === 'sent' && `color: ${textColor};`}'>${text}</p>
        </div>
      </div>
    </div>
  </div>
</div>`;
  messageContainer.innerHTML = msg_context;
  const msg_box = document.getElementById('SPIKE-MSG-BOX');
  msg_box.append(messageContainer);

  spikeScrollToBottom();
}

// ====================================================

function spikeScrollToBottom() {
  const chatBody = document.getElementById('SPIKE-MSG-BOX');
  chatBody.scrollTop = chatBody.scrollHeight;
}

// document
//   .getElementById("spike-send-button")
//   .addEventListener("click", spikeSendPrompt);

// document
//   .getElementById("spike-prompt")
//   .addEventListener("keyup", function (event) {
//     if (event.keyCode === 13 && !event.shiftKey) {
//       event.preventDefault();
//       spikeSendPrompt();
//     }
//   });

function spikeResetChat() {
  const endIndex = spikeConversation.findIndex((item) => item.content === 'END OF DATA');

  // If "END OF DATA" is found, remove all objects from that index to the end
  if (endIndex !== -1) {
    spikeConversation.splice(endIndex + 2);
  }
  document.getElementById('SPIKE-MSG-BOX').innerHTML = '';
}

async function spikeGetData(chatId) {
  try {
    const response = await fetch(API_PATH + `api/data/getting/${spikeAuthentication}?id=${chatId}`, {
      method: 'GET'
      // credentials: 'include'
      // mode: "no-cors",
    });
    return await response.json();
  } catch (error) {
    console.error('Error in getting Data:', error);
  }
}

function spikeRemoveLastMessage() {
  const data = document.getElementById('SPIKE-MSG-BOX')?.querySelectorAll("[name='spikeMessageContainer']");
  if (data && data.length > 0) {
    const lastElementIndex = data.length - 1;
    const lastElement = data[lastElementIndex];
    lastElement.remove();
  }
}

async function spikeUpdateLeads(data) {
  var myHeaders = new Headers();
  myHeaders.append('Content-Type', 'application/json');
  try {
    const response = await fetch(API_PATH + 'api/leads', {
      method: 'POST',
      headers: myHeaders,
      body: JSON.stringify({ ...data, authId: spikeAuthentication, chatId: spikeChatId })
    });
    return await response.json();
  } catch (error) {
    console.error('Error in getting Data:', error);
  }
}

async function leadsHandler(e) {
  e.preventDefault();
  // convert form data to json
  const formData = new FormData(e.target);
  const data = Object.fromEntries(formData.entries());
  const res = await spikeUpdateLeads(data);
  if (res) {
    localStorage.setItem('spikeContact', JSON.stringify(data));
    spikeRemoveLastMessage();
  }
  // save local storage data contact:
}